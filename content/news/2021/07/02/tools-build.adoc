= tools.build
Fogus
2021-07-02
:jbake-type: post

ifdef::env-github,env-browser[:outfilesuffix: .adoc]

== Rethinking the problem

Clojure has evolved over the years and countless individuals and organizations have contributed to the growing success of its ecosystem. Contributing to that success have been various takes on build systems for Clojure but until now there has not been a build solution packaged with the language. Previously, applications written in Clojure often did not strictly require build artifacts, but the community has adopted the Java host ecosystem’s artifact-focused approach. Instead, we took the approach that by default source-based dependencies would be the baseline model. To facilitate this model, significant work has gone into developing and releasing various capabilities and tools, starting with the release of Clojure 1.9, including the following:

- deps.edn and https://github.com/clojure/tools.deps.alpha/[tools.deps] - a structure for declaring dependencies and tools for building classpaths from them
- https://github.com/clojure/brew-install[CLI] - a command line Clojure program runner
- https://github.com/clojure/tools.gitlibs[tools.gitlibs] - a library for dealing with Git repositories

Herein we'll describe the latest effort to supply a "batteries-included" story for Clojure builds called https://github.com/clojure/tools.build[tools.build] and https://clojure.org/reference/deps_and_cli#tool_install[CLI support for tools].

== Improving Source Libs

Clojure’s dynamic nature allows us to rethink the way that new libraries and applications are created. That is, we’d rather work directly with source code as our dependencies than static deployed artifacts. Clojure’s new tools.build feature leverages the tools.gitlib library to work with source repositories as dependencies. In addition to working with Git repositories on common hosting services (e.g. Github, Gitlab, etc.) application developers can depend on certain commit SHAs or tagged versions directly.

```clojure
{:paths ["src"]
 :aliases
 {:build {:deps {io.github.clojure/tools.build {:tag "TAG" :sha "SHA"}}
          :ns-default build}}}
```

It’s likely that some of these source dependencies will require some kind of preparation before they’re applied to the application or development classpath. In those cases tools.build works with the notion of “unprepped” dependencies, or those that require some kind of preparation before they are usable as dependencies. A common type of “prepable” dependency would be a Java source library that requires compilation before it’s usable as a dependency. Such a dependency is declared as below:

```clojure
{:paths ["src" "target/classes"]
 :deps/prep-lib {:alias :build
                         :fn compile
	 	   :ensure "target/classes"}}
```

The tools.build library will check for the presence of that `target/classes` directory and if it’s not found will execute the associated `compile` task, thus compiling the Java source to the `target`.

== Builds as programs

At its base tools.build uses functions that take a single map containing the key/value mappings of its execution parameters. These “tasks” define a logically coherent portion of a build process.

To learn more about the tasks supplied by tools.build you can https://clojure.org/reference/tools_build[read the tools.build reference].

footnote:[You can also run the CLI command `clj -X:deps clojure.tools.cli.help/doc :ns clojure.tools.build.api` if tools.deps.alpha is a dependency in your deps.edn file in the `build` alias.]

These task functions are used to build build-specific _target functions_ in a build.clj file that describe the possible build functions. For example, a simple `clean` target is defined as:

 ```clojure
(defn clean [_]
  (b/delete {:path "target"}))
```

The `clean` target calls out to the tools.build task function `delete` to perform the sub-process that removes a `target` directory. That tools.build uses functions to describe builds means that target functions may be composable as long as their expected keys do not clash. Indeed, to build higher-level build processes one need only define a function that calls its sub-processes in turn as shown below:

```clojure
(defn jar [_]
  (clean nil)
  (b/sync-pom {:class-dir class-dir
               :lib lib
               :version version
               :basis basis
               :src-dirs ["src"]})
  (b/copy-dir {:src-dirs ["src" "resources"]
               :target-dir class-dir})
  (b/jar {:class-dir class-dir
          :jar-file jar-file}))
```

The `jar` process uses both tools.build core task functions (e.g. `copy`) and the previously defined `clean` target to perform the process of building a JAR file. While building aggregate targets by defining functions in your build.clj file is convenient, there are times when you may want to execute ad-hoc sequences of targets. To perform this, the Clojure CLI allows you to execute a pipeline of functions on the command line, as shown below:

```bash
clj -X:build clean jar :env :dev
```
The kv params are passed at the end and will be used to invoke the first function, `clean`, then the return of that will be passed to `jar`.

== Tools

In addition to the support for builds, the Clojure CLI was enhanced with the ability to explore, install, invoke, and introspect tools based on a set of conventions for tool creators. Installing a new CLI tool such as Sean Corfield's https://github.com/seancorfield/clj-new[clj-new] library is a simple as running the following command:

```bash
clj -Ttools install io.github.seancorfield/clj-new '{:git/tag "v1.1.309"}' :as new
```

The use of a Git library name `io.github.seancorfield/clj-new` and a coordinate tag `v1.1.309` allows the CLI to find, build, and install the tool as `new`, which is the name that is used for invocation, a la `clj -Tnew <function> <args>`.

The CLI also provides a way to explore the available versions of tools with the `clj -X:deps find-versions` command that will list the tags available for that tool. There's more to the tools story including listing installed tools, uninstalling tools, and even exploring the available functions and their details for an installed tool using the https://clojure.org/reference/deps_and_cli#other-programs[help/doc and help/dir functions]. One additional feature added to the CLI is the ability to pass https://clojure.org/reference/deps_and_cli##trailing-map-argument[a trailing map] that represents new or augmenting key value pairs as the arguments to invoke functions.

More information on the new https://clojure.org/reference/deps_and_cli#tool_install[tools support in the CLI is available in the reference docs on the Clojure site].

== Getting Started

If you’d like to start using tools.build then the following resources should help you along the path.

**TODO: uninstall + install steps**

???[Alex Miller's talk about tools.build and tool support in the CLI]

???[tools.build reference]
???[tools.build guide]
???[tools.deps guide]

???[Sample project]

???[tools.build Github repository]

A https://clojure.org/guides/tools_build[more comprehensive discussion of the build.clj] file under discussion in this post is available on the Clojure website. Issues and bugs can be reported on the ???[tools.build Jira project].
