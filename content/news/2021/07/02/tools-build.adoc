= tools.build
Fogus
2021-07-02
:jbake-type: post

ifdef::env-github,env-browser[:outfilesuffix: .adoc]

== Rethinking the problem

Clojure has evolved over the years and countless individuals and organizations have contributed to the growing success of its ecosystem. Contributing to that success have been various takes on build systems for Clojure but until now there has not been a build solution packaged with the language. Previously, applications written in Clojure often did not strictly require build artifacts, but the community has adopted the Java host ecosystem’s artifact-focused approach. Instead, we took the approach that by default source-based dependencies would be the baseline model. To facilitate this model, significant work has gone into developing and releasing various capabilities and tools, starting with the release of Clojure 1.9.

- deps.edn and https://github.com/clojure/tools.deps.alpha/[tools.deps] - a structure for declaring dependencies and tools for building classpaths from them
- https://clojure.org/reference/deps_and_cli[CLI] - a command line Clojure program runner
- https://github.com/clojure/tools.gitlibs[tools.gitlibs] - a library for dealing with Git repositories

Herein we'll describe the latest effort to supply a "batteries-included" story for Clojure builds called https://github.com/clojure/tools.build[tools.build] and https://clojure.org/reference/deps_and_cli#tool_install[CLI support for tools].

== Improving Source Libs

Clojure’s dynamic nature allows us to rethink the way that new libraries and applications are created. That is, we’d rather work directly with source code as our dependencies than static deployed artifacts. Clojure’s new tools.build feature leverages the tools.gitlib library to work with source repositories as dependencies. In addition to working with Git repositories on common hosting services (e.g. Github, Gitlab, etc.) application developers can depend on certain commit SHAs or tagged versions directly.

```clojure
{:deps {GIT-LIB {:git-tag "TAG" :git-sha "SHA"}
```

In the dependency above we've settled on a standard way to indicate source dependencies using a service-specific library name coupled with a Git tag and prefix SHA, used for verification. In the case of the tools.build library itself, the Github tag (indicated above by `GIT_LIB`)  becomes `io.github.clojure/tools.build`. More information on specifying Git source dependencies is found in the https://clojure.org/reference/deps_and_cli#using-git-libraries[CLI and deps guide].

Occasionally, source dependencies will require preparation (e.g. compilation, text replacement, etc.) before they’re suitable for inclusion on the classpath. In those cases tools.build works with the notion of “unprepped” dependencies, or those that require some kind of preparation before they are usable as dependencies. A common type of “prepable” dependency would be a Java source library that requires compilation before it’s usable as a dependency. Such a dependency is declared as below:

```clojure
{:deps/prep-lib {:alias :build
                :fn compile
                :ensure "target/classes"}}
```

The tools.build library will check for the presence of that `target/classes` directory and if it’s not found will execute the associated `compile` task, thus compiling the Java source to the `target`. More information on supporting unprepped dependencies is available on the https://clojure.org/reference/deps_and_cli##preparing-source-dependency-libs[Clojure deps guide detailing preparing source dependencies].

== Builds as programs

At its base tools.build uses functions that take a single map containing the key/value mappings of its execution parameters. These “tasks” define a logically coherent portion of a build process. To learn more about the tasks supplied by tools.build you can https://clojure.org/guides/tools_build[read the tools.build reference].footnote:[You can also run the CLI command `clj -X:deps help/doc :ns clojure.tools.build.api` if tools.build is a dependency in your deps.edn file under the `build` alias.]

These task functions are used to build build-specific _target functions_ in a build.clj file that describe the possible build functions runnable at the REPL and aggregated in your personal build.clj files. An example of using tools.build task functions to build up project-specific target functions in a build.clj file is given in the https://clojure.org/guides/tools_build#source-library-jar-build[tools.build guide].

While building aggregate targets by defining functions in your build.clj file is convenient, there are times when you may want to execute ad-hoc pipelines of task and target functions. To perform this, the Clojure CLI allows you to describe and execute a pipeline of functions on the command line, as shown below:

```bash
clj -X:build clean jar :env :dev
```

The kv params are passed at the end and will be used to invoke the first function, `clean`, then the return of that will be passed to `jar`.

== Tools

In addition to the support for builds, the Clojure CLI was enhanced with the ability to explore, install, invoke, and introspect tools based on a set of conventions for tool creators. Installing a new CLI tool such as Sean Corfield's https://github.com/seancorfield/clj-new[clj-new] library is a simple as running the following command:

```bash
clj -Ttools install io.github.seancorfield/clj-new '{:git/tag "v1.1.309"}' :as new
```

The use of a Git library name `io.github.seancorfield/clj-new` and a coordinate tag `v1.1.309` allows the CLI to find, build, and install the tool as `new`, which is the name that is used for invocation, a la `clj -Tnew <function> <args>`.

The CLI also provides a way to explore the available versions of tools with the `clj -X:deps find-versions` command that will list the tags available for that tool. There's more to the tools story including listing installed tools, uninstalling tools, and even exploring the available functions and their details for an installed tool using the https://clojure.org/reference/deps_and_cli#other-programs[help/doc and help/dir functions]. One additional feature added to the CLI is the ability to pass https://clojure.org/reference/deps_and_cli##trailing-map-argument[a trailing map] that represents new or augmenting key value pairs as the arguments to invoke functions.

More information on the new https://clojure.org/reference/deps_and_cli#tool_install[tools support in the CLI is available in the reference docs on the Clojure site].

== In summary

The Clojure core team has worked hard to provide a story for builds and tooling, including:

- tools.build - a new library for writing build programs (???[reference], ???[guide], ???[source], ???[issues])
- Support for running multiple functions at the CLI and passing trailing maps as arguments
- Source deps support - inferred git urls, tags for versions, lib prep
- Tool support - tool installation and use, better introspection

If you’d like to start using tools.build then the following information should help you along the path.

**TODO: uninstall/install/version/etc.**

???[Alex Miller's talk about tools.build and tool support in the CLI]
???[Sample project]

A https://clojure.org/guides/tools_build[more comprehensive discussion of the build.clj] file under discussion in this post is available on the Clojure website. Issues and bugs can be reported on the ???[tools.build Jira project].
