= tools.build
Fogus
2021-07-02
:jbake-type: post

ifdef::env-github,env-browser[:outfilesuffix: .adoc]

== Rethinking the problem

Clojure has evolved over the years and countless individuals and organizations have contributed to the growing success of its ecosystem. Contributing to that success have been various takes on build systems for Clojure but until now there has not been a build solution packaged with the language. Previously, applications written in Clojure often did not strictly require build artifacts, but the community has adopted the Java host ecosystem’s artifact-focused approach. Instead, we took the approach that by default source-based dependencies would be the baseline model.

However, some libraries need some sort of preparation to create the resources needed on the classpath. The preparation needed ranges from compilation of Java or Clojure source to rote text replacement in project resources to other, project-specific tasks. The Clojure build story should facilitate the preparation and detection of the need for such tasks when necessary. For the past year the Clojure core team has worked to create a build story for Clojure that facilitates the needs described above. The effort, released as tools.build, is described herein.

== Improving Source Libs

Clojure’s dynamic nature allows us to rethink the way that new libraries and applications are created. That is, we’d rather work directly with source code as our dependencies than static deployed artifacts. Clojure’s new tools.build feature leverages the tools.gitlib library to work with source repositories as dependencies. In addition to working with Git repositories on common hosting services (e.g. Github, Gitlab, etc.) application developers can depend on certain commit SHAs or tagged versions directly.

```clojure
{:paths ["src"]
 :aliases
 {:build {:deps {io.github.clojure/tools.build {:tag "TAG" :sha "SHA"}}
          :ns-default build}}}
```

It’s likely that some of these source dependencies will require some kind of preparation before they’re applied to the application or development classpath. In those cases tools.build works with the notion of “unprepped” dependencies, or those that require some kind of preparation before they are usable as dependencies. A common type of “prepable” dependency would be a Java source library that requires compilation before it’s usable as a dependency. Such a dependency is declared as below:

```clojure
{:paths ["src" "target/classes"]
 :deps/prep-lib {:alias :build
                         :fn compile
	 	   :ensure "target/classes"}}
```

The tools.build library will check for the presence of that `target/classes` directory and if it’s not found will execute the associated `compile` task, thus compiling the Java source to the `target`.

== Builds as programs

When designing a build solution for Clojure the temptation to build a bespoke declarative interface is strong. However, declarative solutions, unlike functions, are by their nature difficult to compose without adding complexity to bear on the problem. The ideal is to create a solution that can compose just as functions so why not simply use functions as the base build API. We’re using our build system to create Clojure applications so why shouldn’t we use Clojure as it’s spoken as the interface to that very build system? Therefore, at its base tools.build uses functions that take a single map containing the key/value mappings of its execution parameters. These “tasks” define a logically coherent portion of a build process.

To learn more about the tasks supplied by tools.build you can https://clojure.org/reference/tools_build[read the tools.build reference].

footnote:[You can also run the CLI command `clj -X:deps clojure.tools.cli.help/doc :ns clojure.tools.build.api` if tools.deps.alpha is a dependency in your deps.edn file in the `build` alias.]

These task functions are used to build build-specific _target functions_ in a build.clj file that describe the possible build functions. For example, a simple `clean` target is defined as:

 ```clojure
(defn clean [_]
  (b/delete {:path "target"}))
```

The `clean` target calls out to the tools.build task function `delete` to perform the sub-process that removes a `target` directory. That tools.build uses functions to describe builds means that target functions may be composable as long as their expected keys do not clash. Indeed, to build higher-level build processes one need only define a function that calls its sub-processes in turn as shown below:

```clojure
(defn jar [_]
  (clean nil)
  (b/sync-pom {:class-dir class-dir
               :lib lib
               :version version
               :basis basis
               :src-dirs ["src"]})
  (b/copy-dir {:src-dirs ["src" "resources"]
               :target-dir class-dir})
  (b/jar {:class-dir class-dir
          :jar-file jar-file}))
```

The `jar` process uses both tools.build core task functions (e.g. `copy`) and the previously defined `clean` target to perform the process of building a JAR file. While building aggregate targets by defining functions in your build.clj file is convenient, there are times when you may want to execute ad-hoc sequences of targets. To perform this, the Clojure CLI allows you to execute a pipeline of functions on the command line, as shown below:

```bash
clj -X:build clean jar :env :dev
```
The kv params are passed at the end and will be used to invoke the first function, `clean`, then the return of that will be passed to `jar`.

== Tools

In addition to the support for builds, the Clojure CLI was enhanced with the ability to explore, install, invoke, and introspect tools for the CLI. 

== Getting Started

If you’d like to start using tools.build then the following resources should help you along the path.

**TODO: uninstall + install steps**

???[tools.build reference]
???[tools.build guide]
???[tools.deps guide]

???[Sample project]

???[tools.build Github repository]

A https://clojure.org/guides/tools_build[more comprehensive discussion of the build.clj] file under discussion in this post is available on the Clojure website. Issues and bugs can be reported on the ???[tools.build Jira project].
